---
title: 面试笔记
noindex: true
---
面试问题
- 公司每月发薪日?
- 工作时间和考勤? 雨天迟到怎么算?
- 部门加班情况和加班费怎么算?
- 公司有电脑还是自带电脑?

**Java**
HashMap 红黑树原因: 可以利用链表对内存的使用率以及红黑树的高效检索, 是一种很有效率的结构. AVL 树是一种高度平衡的二叉树, 所以查找效率非常高, 但是为了维护这种高度平衡, 要付出更多的代价. (每次插入, 删除都要做调整)

**多线程线程池**
- newSingleThreadExecutor: 单线程的线程池，可保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行.
- newFixedThreadPool: 固定大小的线程池，可控制并发的线程数，超出的线程会在队列中等待.
- newCachedThreadPool: 可缓存的线程池，若线程数超过处理所需，缓存一段时间后会回收，若线程数不够，则新建线程.
- newScheduledThreadPool: 周期性的线程池，支持定时及周期性执行任务.

ThreadPoolExecutor 线程池, corePoolSize = 5, maximumPoolSize = 10, queueCapacity = 10, 有 20 个耗时任务交给这个线程池执行, 线程池会如何执行这20个任务?
- 如果当前线程数 < corePoolSize, 则创建新线程执行该任务.
- 如果当前线程数 >= corePoolSize, 则将任务存入队列.
- 如果阻塞队列已满, 且当前线程数 < maximumPoolSize, 则新建线程执行该任务.
- 如果阻塞队列已满, 且当前线程数 >= maximumPoolSize, 则抛出异常.

**AQS** (AbstractQueuedSynchronizer) 是抽象队列同步器, 主要用来构建锁和同步器. ReentrantLock, Semaphore 都是基于 AQS 构造的. 

AQS 核心思想: 如果请求的共享资源空闲, 就将请求资源的线程设为有效的工作线程, 并将共享资源设为锁定状态. 如果共享资源被占用, 那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制, 这个机制 AQS 是基于 CLH锁 (Craig, Landin, and Hagersten locks) 实现的.

CLH锁是对自旋锁的一种改进, 是一个虚拟的双向队列 (不存在队列实例, 仅存在结点之间的关联关系), 暂时获取不到锁的线程将被加入到该队列中.

Java内存区域(运行时数据区域)
![](/picture/java-runtime-data-areas-jdk1.8.png)
- 程序计数器: 1.字节码解释器通过改变它来依次读取指令, 实现代码流程控制. 2. 多线程情况下, 用于记录线程执行位置.
- 虚拟机栈: 为虚拟机执行 Java 方法 (也就是字节码) 服务. 栈内存不允许动态扩展且栈深度超出最大深度时, 抛出 StackOverflow. 虚拟机在动态扩展栈时无法申请到足够的内存空间, 则抛出 OutOfMemoryError.
- 本地方法栈: 为虚拟机使用到的 Native 方法服务.
- 堆: 存放对象实例, 几乎所有对象实例以及数组都在这里分配内存. 随着 JIT 编译器 (Just-In-Time) 的发展与逃逸分析技术逐渐成熟, 栈上分配, 标量替换优化技术导致一些微妙的变化. 堆是垃圾收集器管理的主要区域, 因此也被称作 GC堆. 进一步划分堆的目的是更好地分配和回收内存.
- 方法区: 运行时数据区域的一块逻辑区域. 存储已被虚拟机加载的类信息, 字段信息, 方法信息, 常量, 静态变量, 即时编译器编译后的代码缓存等数据. 具体实现: 永久代/元空间.

对象的创建 (类分初设执)
- 1. 类加载检查
虚拟机遇到 new 指令时, 检查是否能在常量池中定位到这个类的符号引用, 检查这个符号引用代表的类是否已被加载, 解析和初始化过. 如果没有则执行类加载过程.
- 2. 分配内存
从堆中为新对象分配内存. 分配方式有**指针碰撞**和**空闲列表**, 选分配方式由堆是否规整决定(就是垃圾收集器是否带有压缩整理功能决定, 标记-清除/标记-整理). 
  - 指针碰撞: 
    - 场合: 内存规整 (没有内存碎片)
    - 原理: 用过的内存整合到一边，没有用过的内存放另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。
    - 该分配方式的 GC 收集器：Serial, ParNew
  - 空闲列表
    - 场合: 内存不规整
    - 原理: 虚拟机维护一个列表，该列表中记录哪些内存块是可用的，分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。
    - 该分配方式的 GC 收集器：CMS

    内存分配并发问题:
    在实际开发过程中，创建对象是很频繁的事情, 必须确保线程安全:
    - TLAB (Thread Local Allocation Buffer):  为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用 CAS 进行内存分配.
    - CAS + 失败重试: 虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
- 3. 初始化零值
虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
- 4. 设置对象头
例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
- 5. 执行 init 方法
从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。

对象的内存布局
Hotspot虚拟机中, 可分为: 对象头, 实例数据, 对齐填充
- 对象头: 一部分用于存储对象自身的运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针.
- 实例数据: 对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。
- 对齐填充: 仅仅起占位作用

堆空间基本结构:
新生代: Eden, S0, S1
老年代: Tenured
永久代: MetaSpace

死亡对象判断
- 引用计数法
每当有一个地方引用它，计数器就+1, 引用失效计数器-1, 计数器为0时代表失效. (简单，效率高，但主流虚拟机没有选择这个算法，主要的原因是它很难解决对象之间相互循环引用的问题。)
- 可达性分析算法
基本思想是通过一系列的称为 “GC Roots” 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。

引用类型
- 强引用: 垃圾回收器绝不会回收. 内存空间不足时抛出 OOM.
- 软引用: 内存充足就不会回收, 内存不足就会回收. 可用来实现内存敏感的高速缓存.
- 弱引用: 比软引用拥有更短的生命周期. 垃圾回收器线程扫描到只具有弱引用的对象, 不管内存空间足够与否, 都会回收它的内存. 由于垃圾回收器是一个优先级很低的线程, 因此不一定会很快发现那些只具有弱引用的对象.
- 虚引用: 如果一个对象仅持有虚引用, 那么它就和没有任何引用一样, 在任何时候都有可能被垃圾回收. 虚引用主要用来跟踪对象被垃圾回收的活动.

程序设计中很少使用弱引用与虚引用, 使用软引用较多, 因为软引用可以加速 JVM 堆垃圾内存的回收速度, 维护系统的运行安全, 防止内存溢出等问题的产生.

判断无用类
- 该类所有实例都已经被回收.
- 加载该类的 ClassLoader 已经被回收.
- 该类对应的 java.lang.Class 对象没有在任何地方被引用, 无法在任何地方通过反射访问该类的方法.

垃圾收集算法
- 标记-清除: 首先标记出所有不需要回收的对象, 标记完成后统一回收掉所有没有被标记的对象. 存在问题:
  - 效率问题
  - 空间问题 (产生大量不连续的碎片)
- 标记-复制: 将内存分为大小相同的两块, 每次使用其中的一块. 一块的内存使用完后，将还存活的对象复制到另一块, 然后再把使用的空间清理掉.
- 标记-整理: 标记过程与“标记-清除”算法一样, 但后续步骤是让所有存活的对象向一端移动, 然后直接清理掉端边界以外的内存.

分代收集算法
根据对象存活周期的不同将内存分为几块.
- 新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。
- 老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。

垃圾收集器
根据具体应用场景选择适合的垃圾收集器.
- Serial 收集器: 单线程, "Stop The World". 新生代采用标记-复制算法，老年代采用标记-整理算法. 简单而高效. 适合 Client 模式下的虚拟机.
- ParNew 收集器:  Serial 收集器的多线程版本. 新生代采用标记-复制算法，老年代采用标记-整理算法. Server 模式下的虚拟机的首选.
- Parallel Scavenge 收集器(JDK1.8 默认): 吞吐量优先. 新生代采用标记-复制算法，老年代采用标记-整理算法.
- CMS 收集器: 并发收集、低停顿. 以获取最短回收停顿时间为目标. 非常符合在注重用户体验的应用上使用. 第一次实现了让垃圾收集线程与用户线程（基本上）同时工作. 缺点: CPU 资源敏感. 无法处理浮动垃圾. 标记-清除 产生大量空间碎片.
- G1 收集器(Java9+ 默认): 面向服务器的垃圾收集器, 针对配备多颗处理器及大容量内存的机器. 以极高概率满足 GC 停顿时间要求的同时, 还具备高吞吐量性能特征.
- ZGC 收集器: 与 CMS 中的 ParNew 和 G1 类似，ZGC 也采用标记-复制算法，出现 Stop The World 的情况会更少.

Minor GC 是只收集新生代的 GC.
Full GC 就是收集整个堆, 包括新生代, 老年代, 永久代(1.8之后换为元空间)等收集所有部分的模式.

类加载过程
加载->连接->初始化
连接又分为: 验证->准备->解析
- 加载: 将 class 文件加载到内存. 静态数据结构(.class .jar .war .jsp)转化成方法区中运行时的数据结构. 在堆中生成代表这个类的 Class 对象.
- 验证: 确保符合 JVM 规范和安全. 
- 准备: 为静态变量在方法区中分配内存空间.
- 解析: 将常量池内的符号引用替换为直接引用.
- 初始化: 执行类静态资源初始化和非静态资源初始化的方法.
- 卸载: GC 将无用对象从内存中卸载.

类加载器加载顺序
1.BootStrap ClassLoader: rt.jar
2.Extension ClassLoader: 加载扩展的 jar 包.
3.App ClassLoader: 指定的 classpath 下面的 jar 包.
4.Custom ClassLoader: 自定义的类加载器.

双亲委派模型
先判断是否被加载过, 已被加载的类会直接返回. 加载的时候，首先会把该请求委派给父类加载器的 loadClass() 处理. 隔离作用, 避免我们的代码影响到 JDK 的代码.

**JVM 问题排查**
- jmap 查看堆各个区域使用情况
- jstack 查看线程和锁的使用情况
- jstat 查看 full gc 发生次数以此判断是否需要调优

Spring 
Spring Bean 初始化
![](/picture/spring-bean-lifestyle.png)
- 实例化, 属性赋值(依赖注入), 初始化, 销毁
- 初始化相关: Aware 接口依赖注入, BeanPostProcessor 在初始化前后的处理, 以及 InitializingBean 和 init-method 的初始化操作.
- 销毁的具体操作, 有注册相关销毁回调接口, 最后通过 DisposableBean 和 destory-method 进行销毁.

Spring AOP 的了解
AOP (Aspect-Oriented Programming 面向切面编程) 能够将那些与业务无关, 被业务模块所共同调用的逻辑封装起来 (事务, 日志, 权限控制等), 便于减少系统的重复代码, 降低模块间的耦合度, 有利于维护和扩展. 

Spring MVC 原理
![](/picture/spring-mvc.png)

**SpringBoot 中 bootstrap.yml 和 application.yml 的异同?**
- bootstrap.yml 先加载, application.yml 后加载.
- bootstrap 是由 SpringCloud 配置上下文加载. application 由 SpringBoot 配置加载.
- bootstrap 属性有高优先级. application 不会覆盖 bootstrap.
- bootstrap 配置一些引导系统启动的参数, 一旦指定后不会变动. 如程序端口号, 配置中心地址等. application 应用级别的参数配置, 可能会根据业务需求做动态配置. 如日志级别, 一些开关参数等.
- bootstrap.yml 和 applicaiton.yml 在同一目录下.

假如配置文件中有相同的配置，后加载的配置会覆盖先加载的配置，所以如果使用Nacos配置中心的话，nacos上的配置的优先级会比较高。

MySQL
MySQL 为什么用 B+树?
- 哈希虽然能提供 O(1) 的单数据行性能, 但对范围和排序无法很好的支持.
- B 树能够在非叶子结点中存储数据, 查询连续数据时可能带来更多的随机 I/O.
- 而 B+ 树叶子节点可以通过指针相互连接, 能够减少顺序遍历时产生的额外随机 I/O.

binlog (二进制日志)
逻辑日志，记录内容是语句的原始逻辑. 记录所有 DDL(Data Definition Language) 和 DML(Data Manipulation Language) 语句. 主要两个作用:
- 数据恢复: 数据操作出问题/数据库宕机数据丢失, 可以根据 binlog 来回放历史数据.
- 主从数据: 多机备份业务, 可以监听写库的 Binlog 日志, 同步写库的所有更改.

redo log (事务日志)
是物理日志，记录内容是“在某个数据页上做了什么修改”，属于 InnoDB 存储引擎。

undo log (回滚日志)

两阶段提交:
写入数据后, InnoDB 把数据保存在内存中, 同时记录 redo log, redo log 进入 prepare 状态, 然后告诉执行器执行完成了. 执行器收到通知后记录 binlog, 然后调用引擎接口, 提交 redo log 为提交状态.

两阶段提交的异常重启:
- 判断 redo log 是否完整, 如果完整则立即提交.
- 如果 redo log 是预提交, 判断 binlog 是否完整, 完整就提交, 不完整则回滚事务.

**MySQL 深分页 limit 优化:**
- 以 last_\* 作为查询条件, 使用浅分页: 没有页码的应用场景.
```
select id, name ...
from t
where id > #{last_id},create_time > #{last_create_time}
order by create_time desc
limit 0, 20;
```
- 连表子查询, 先查询 id 再通过 in 查详情:  
```
SELECT   
    id, m_id, NAME, identity_no, address, create_time, modify_time 
FROM t2
JOIN ( SELECT id FROM t2 ORDER BY create_time desc LIMIT 1000000, 20 ) x USING ( id );
```

**MySQL 分库分表**
分表策略:
- range 范围: 比如根据 id, 0到300万一张表, 300万到600万一场表.
- hash 取模: 指定 key 取模, 数据分到不同的表中.
- 一致性哈希: 在移除或者添加一个服务器时，能够尽可能小地改变已存在的服务请求与处理请求服务器之间的映射关系。解决分布式哈希中的动态伸缩问题.

Redis
5种基本数据结构
- String (字符串): 场景: 缓存 token, 图片地址, 序列化后的对象.
- List (列表): 实现为双向链表. 场景: 最新文章, 最新动态.
- Set (集合): 无序集合. 轻易实现交集, 并集, 差集操作. 场景: 1. 存放数据不能重复的场景, 网站 UV 统计(数量巨大就用 HyperLogLog). 共同好友. 2. 需要随机获取数据源中的元素的场景, 抽奖.
- Sorted Set (有序集合): 比 Set 多了 score 权重参数. 场景: 1. 需要随机获取数据源中的元素根据某个权重进行排序, 排行榜. 2. 需要存储的数据有优先级或者重要程度的场景, 优先级任务队列.
- Hash (哈希): String 类型的键值对. 场景: 对象数据存储(用户信息、商品信息、文章信息、购物车信息. )
- HyperLogLogs (基数统计): 场景: 数量量巨大（百万、千万级别以上）的计数场景, 热门网站每日/每周/每月访问 ip 数统计.
- Bitmap (位存储): 只需要一个 bit 位来表示某个元素对应的值或者状态. 场景(0/1即可表示): 用户签到情况, 用户行为统计(点赞过某个视频).
- Geospatial (地理位置): 底层也是 GeoHash. 场景: 附近的人.

**跳表** (skiplist)
由多层链表组成, 通过先比较上一层的大小, 可以很快找到该值在下一层的区间范围. 时间复杂度 log(n).
![skiplist](/picture/interview-Skip_list_add.gif)
跳表比B+树层级更高，需要更多的磁盘I/O. 但 Redis 是基于内存的数据库, 不用考虑磁盘 I/O 影响性能问题.

**压缩列表** (ziplist)
本质上就是一个字节数组，是Redis为了节约内存而设计的一种线性数据结构，可以包含多个元素.
![ziplist](/picture/interview-ziplist.png)
存储空间连续结构在数据量小时可以有效节省空间, 但数据量比较多, 修改元素时, 必须重新分配存储空间, 会影响执行效率.

**quicklist**
是 LinkedList 和 ziplist 的混合. 将 LinkedList 按段切分, 每一段使用 ziplist 存储. 多个 ziplist 使用双向指针串联器来.
![quicklist](/picture/interview-quicklist.webp)

内存淘汰机制
Redis 提供 6 种数据淘汰策略:
1. volatile-lru (least recently used): 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰.
2. volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰. 
3. volatile-random：从已设置过期时间的数据集中任意选择数据淘汰. 
4. allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）.
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰. 
6. no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。

4.0版本后增加了:
7. volatile-lfu（least frequently used）：从已设置过期时间的数据集中挑选最不经常使用的数据淘汰. 
8. allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key.

持久化机制
1. 快照（snapshotting，RDB）
将 Redis 某一时刻的数据持久化到磁盘中. 是一种快照式的持久化方案. RDB 是一个非常紧凑(有压缩)的文件. 适合备份, 远程传输. 通常用于主从, 提高 Redis 性能, 还可以留在本地重启时使用.
Redis 提供了两个命令来生成 RDB 快照文件：
- save : 主线程执行，会阻塞主线程；
- bgsave : 子线程执行，不会阻塞主线程，默认选项。

RDB 缺点: 
- 基于时间间隔的, 可能存在一定程度的数据丢失. 
- 子进程占用和主进程相同的内存空间, 可能导致内存不足.

2. 只追加文件（append-only file, AOF）
AOF 方式是将执行过的写指令记录下来, 在数据恢复时按照从前到后的顺序再将指令都执行一遍. 比快照式实时性更好.
开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。
三种不同的AOF持久化方式:
- always: 每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
- everysec: 每秒钟同步一次，显式地将多个写命令同步到硬盘
- no: 让操作系统决定何时进行同步

AOF 缺点: 
- 较大的存储空间: 与 RDB 相比, AOF 文件通常较大, 占用较多磁盘空间.
- 数据加载速度慢: 由于需要重放 AOF 文件中的命令, 恢复速度相对较慢.

3. 混合持久化 (RDB + AOF)
Redis 首先使用 RDB 持久化将内存中的数据快照存储到磁盘上, 然后再使用 AOF 持久化将所有新的写操作追加到 AOF 文件中.
- 在系统崩溃时, 可以通过 RDB 文件快速恢复, 而 AOF 文件可以用于恢复最近的修改.
- RDB 持久化可以减少 AOF 文件的大小, 从而减少磁盘空间的使用.
- 在 RDB 持久化中, Redis 可以使用子进程来将快照写入磁盘, 这样可以避免主进程的阻塞.

缺点: 
较大的存储空间, 需要同时维护 RDB 文件和 AOF 文件, 可能占用较多的磁盘空间.

**布隆过滤器**
布隆过滤器在缓存架构中主要用于防止缓存穿透，通过提前判断 key 是否可能存在，拦截掉一定不存在的请求，减少无效的缓存和数据库访问，从而保护系统稳定性。

**怎么保证 Redis 缓存跟数据库数据一致性问题?**
方案1: 先更新数据库, 再删除缓存键, 读请求会穿透到数据库, 再回填缓存. 
- 优: 简单直观, 最终一致性
- 缺: 高并发下有短时间脏数据 (读到旧数据, 缓存回填了旧数据)

方案2: 延迟双删. 方案1 基础上, 延迟一小段时间 (如500ms) 再次删除缓存.
- 优: 防止缓存回填旧数据
- 缺: 延迟时间不好调，过短无效，过长影响性能

方案3: 异步消息通知删除缓存. 
- 优: 解耦, 延迟低
- 缺: 依赖 MQ 可用性, 需要幂等处理

方案4: 读写一致的分布式锁
- 优: 写操作加锁, 防止回填脏数据
- 缺: 性能下降, 适合高一致性场景

**什么是深拷贝和浅拷贝? JavaScript 对象如何进行深拷贝?**
浅拷贝只是增加了一个指针指向已存在的内存. 深拷贝就是增加一个指针并且申请一个新的内存, 使这个增加的指针指向这个新的内存.
JSON.parse( JSON.stringify() )
先将需要拷贝的对象进行 JSON 字符串化, 然后再 parse 解析出来.

**什么是 SQL 注入? 如何防止?**
SQL注入是一种常见的Web应用安全漏洞，可以通过在SQL语句中插入恶意代码来破坏数据库的完整性。
- 对数据进行有效性检查, 如限制字符集, 长度以及格式.
- 使用预处理语句或存储过程.
- 使用参数化查询, 避免直接在 SQL 语句中拼接用户输入的数据.
- 限制对数据库的访问权限, 只允许必要的操作.
- 定期执行安全审计和监测, 以及对发现的漏洞进行及时修复.

**MQ 重复消费, 消息幂等**
- 改造业务, 使得重复消费时不影响最终结果: version 版本号控制.
- 基于数据库唯一主键进行约束, 消费完向数据库 insert, 如果重复消费就会主键冲突.
- 通过记录关键 key, 重复消息过来时, 先判断 key 是否被处理过.

**MQ 如何保证消息不丢失, 进行可靠传输?**
- RabbitMQ提供事务机制（transaction）和确认机制（confirm）两种模式来确保生产者不丢消息.
- 通过开启持久化磁盘来确保消息队列不会丢数据.
- 采用手动确认代替自动确认, 确保处理完后再发送确认. 确保消费者不丢消息.

**文章类**

[The Java® Virtual Machine Specification JVM 虚拟机规范 (oracle)](https://docs.oracle.com/javase/specs/jvms/se8/html/index.html)
[JavaGuide 面试 (javaguide)](https://javaguide.cn/)

**问答类**

[Git IncludeIf (ayase)](https://ayase.moe/2021/03/09/customized-git-config/)
[Java Concurrency  yield, sleep, join Methods (geeksforgeeks)](https://www.geeksforgeeks.org/java-concurrency-yield-sleep-and-join-methods/)
[jodiejackson](https://jodiejackson.com)
[wait and notify() Methods in Java (baeldung)](https://www.baeldung.com/java-wait-notify)
[wait, notify, await, signal (Java并发编程实战)]Condition 对象中, 与 wait, notify, notifyAll 方法对应的分别是 await, signal, signalAll. 但是, Condition 对 Object 进行了扩展, 因而它也包含 wait 和 notify 方法. 一定要确保使用正确的版本, await 和 signal.
